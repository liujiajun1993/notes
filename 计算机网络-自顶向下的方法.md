(注：特别重要的部分使用article标签包裹)

## 一、概论
1. 交换式网络
  - 电路交换网络
  - 分组交换网络

2. 协议分层
  - 优点：将服务从实现中分离出来。例如如果需要修改或更换应用层协议，只需要修改相应的应用层设备即可

3. TCP/IP协议簇
   ![](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1-1.png)
   主机间通信方法, 注意交换机和路由器的区别。路由器涉及多个数据链路层和物理层的结合，因此需要更高一层的网络层。![主机间通信方法](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1-2.png)
   应用层、传输层、网络层属于端对端（end-to-end），而数据链路层和物理层属于点对点（hop-to-hop），必须经过一个主机或者一个路由器一步一步传递。
   1. 应用层，进程之间的通信，HTTP/SMTP/FTP/TELNET/SSH/DNS...
   2. 传输层，向应用层提供服务，将应用层信息投递到目标主机。TCP/UDP/SCTP(流控制传输协议)
   3. 网络层，在院计算机和目标计算机之间创建一个连接。IP/DHCP/ARP（地址解析协议）/ICMP（因特网控制报文协议）/IGMP（因特网组管理协议）
   4. 数据链路层，将数据包封装在frame（帧）中
   5. 物理层。携带frame中的bit穿过链路

4. 封装和解封装
  应用层message -> 传输层segment(TCP)/user datagram(UDP) -> 网络层(datagram, 添加自己的头部) -> 数据链路层(frame, 添加自己的头部) -> 物理层
   
5. 地址
  每一层协议（除了物理层）都需要地址来对应通信的双方。
  传输层的地址对应端口号，网络层地址对应网络IP，链路层地址对应MAC地址。链路层地址用于在网络中定义一个特定的主机或者路由器。

6. OSI模型（注意是模型不是协议）
  ![OSI七层模型](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1-3.png)
  相对于TCP/IP协议簇，多了会话层和表示层，一般认为TCP/IP的应用层包含了它们
  OSI模型最终并没有替代TCP/IP协议簇
  
----------
## 二、应用层
  TCP/IP协议簇的层次结构是的因特网比其他网络诸如电话网络、广播网络更灵活，只需要加入新的协议就可以支持新的服务。

### 2.1 客户-服务器模式
   应用层与操作系统（操作系统封装了之后的四层接口）的通信通过API接口实现。包括套接字接口（socket），传输层接口（Transport Layer Interface, TLI)以及STREAM。
   套接字地址 = IP地址 + 端口号
   
   **URI** = 协议 + 主机 + 端口 + 路径
   
   <strong style="color: #f00">万维网</strong>是无数个网络站点和网页的集合，它们在一起构成了<strong style="color:#f00">因特网</strong>最主要的部分（因特网也包括电子邮件、Usenet以及新闻组）。它实际上是多媒体的集合，是由<strong style="color:#0f0">超级链接 (hyper)</strong>连接而成的。
   万维网和互联网的区别，互联网是通过电缆将计算机连接起来的物理网络，万维网是建立在互联网上的虚拟网络，用于提供超文本服务。
   
   <strong style="color: #f00">超文本传输协议(HTTP)</strong>定义客户服务器如何从万维网获取网页的协议。使用TCP服务，在客户和服务器进行任何事务之前，必须建立连接。
   
   **持续连接**一次TCP连接可以响应多次请求
   
   **HTTP请求报文**
   ![请求报文和响应报文格式](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-1.png)
   ![请求头部](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-2.png)
   ![响应头部](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-3.png)
   
   **请求条件**缓存的四种条件，参考[浏览器缓存知识小结及应用](http://www.cnblogs.com/lyzg/p/5125934.html)或印象笔记中的剪藏：
   - Expires，对比时间
   - Cache-Control,设置max-age=毫秒数
   - Last-Modified/If-Modified-Since
   - Etag/If-None-Match
  

   **Cookie**
   
   **代理服务器**代理服务器是一台计算机，能够保存最近请求的响应副本。如果没有命中缓存，就向响应的服务器发送请求。
   代理服务器既是一个服务器又是一个客户。
   
   **HTTP安全**HTTPS提供保密性、客户和服务器鉴别，以及数据完整性保证。
   
   <strong style="color: #f00">FTP</strong>更适用于传输大文件或者使用不同格式传送文件。
   ![FTP传输过程](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-4.png)
   注意FTP的控制进程和数据传输进程是**分开的**。*21端口*用于控制链接，*20端口*用于数据连接。整个FTP会话过程中，控制连接始终处于连接状态，当文件传输命令执行时，数据连接就打开，传输完毕就关闭。
   FTP的数据传输进程略。
   安全的FTP建立在SSL层上，成为SSL-FTP。
   
   <strong style="color: #f00">SMTP</strong>定义MTA客户机和服务器之间的常用协议。用于邮件的发送。
   ![邮件发送过程](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-5.png)
   邮件传输过程：连接建立（服务器返回代码220->客户发送HELO报文->服务器返回250）、邮件传输、连接终止（服务器返回221）
   
   <strong style="color: #f00">POP/IMAP</strong>SMTP定义发送邮件(push)的协议，pull阶段使用报文访问代理协议，一般有两种，分别为POP3和IMAP4。
   相对而言，IMAP4更复杂，但功能更多。
   
   **MIME**多用途因特网邮件扩充，允许非ASCII数据通过电子邮件传送。
   
   <strong style="color: #f00">TELNET</strong>，用于远程登录。考虑到安全问题，升级为SSH。
   ![远程登录流程](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-6.png)
   
   <strong style="color: #f00">SSH</strong>
   ![SSH组件](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-6.png)
   SSH传输层协议建立在TCP协议上，建立安全信道，保证保密性、数据完整性、服务认证和报文压缩。
   SSH认证协议让服务器认证客户。
   SSH连接协议用于通信逻辑。
   
   <strong style="color: #f00">DNS</strong>
   ![DNS名字服务器](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-7.png)
   
### 2.2 对等模式（P2P模式）
   不需要一个不断运行并等待客户进程连接的服务器进程。（迅雷。。。）
   一个对等节点既可以是客户，也可以是服务器。
   对等模式，当网络中一个对等节点有文件要共享，那么它使其他对等节点都能获得这个文件。
   
   **P2P网络**
   集中式P2P网络，使用客户-服务器模式，但是文件存储和下载使用对等模式完成。对等节点现在中心服务器进行注册，提供要分享的文件列表。
   分散式P2P网络，对等节点将自身置于覆盖网中，按照节点连接方式又分为非结构化分散式P2P网络和结构化分散式P2P网络。非结构化中，节点随机连接，搜索效率不高。结构化网络采用一组阈限确定的规则连连接节点，有效并高效地解决查询。
   
   **分布式散列表（DHT）**
   按预先定义的规则将数据分发到一组节点上。（利用散列表可以直接获得要查询的数据的存储节点）
   ![DHT查询方法](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-9.png)
   
### 2.3 套接字接口编程
套接字只起到一个引用或标签的作用，既不能发送也不能接收数据。
套接字结构的<span style="color: #f00">五个字段</span>：
   - 族（协议簇，通常是PF_INET/PF_INET6）
   - 类型（SOCK_STREAM用于TCP，SOCK_DGRAM用于UDP，SOCK_SEQPACKET用于，SOCK_RAW用于ISP服务）
   - 协议。定义族中特定协议，对于TCP/IP字段设为0
   - 本地套接字地址，一个结构，由长度字段、族字段、端口号字段以及IP地址字段构成。本地端口号一般是临时端口号。
   - 远程套接字地址。远程端口号一般是约定俗成的特定端口号。

  **UDP通信流程**  客户和服务器每一端都只使用一个套接字。服务器端的套接字永远运行。
  ![UDP通信流程](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-10.png)
  （咦，代码跟深入了解计算机系统里好像。。。）
  
  **TCP通信**  面向连接的协议。服务器使用*两个*套接字，一个用于建立（监听套接字）一个用于传输。客户只使用一个套接字用于连接以及数据交换。
  ![TCP通信流程](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-11.png)

------
## 三、传输层
因特网上从一点到另一个点传输数据的端到端逻辑传输媒介。
### 3.1 介绍
传输层提供进程到进程的通信，进程是传输层服务的应用层实体。
网络层提供主机到主机的通信，投递到正确的进程需要传输层协议。
![网络层与传输层的作用区别](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3-1.png)

IP地址在全世界范围确定一个主机，而端口号在该主机上确定特定的进程
![IP地址和端口号的作用](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3-2.png)

<br>
熟知端口号存储在/etc/services文件中，每行给出服务器名和熟知端口号
![ICANN端口号编码范围](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3-3.png)

**封装与解封装
封装：传输层从应用层接收数据并加入传输层头部。
解封装：报文到达后头部被丢弃，将报文传递给应用层。**

**流量控制**
当服务器推数据时，可能存在消费者被淹没的情况，因此需要流量控制来通知生产者停止传递，并在准备好接收数据时通知生产者。
通常采用<span style="color:#f00">两个缓冲区</span>，分别位于发送方的传输层（发送方的应用层和传输层）和接收方的传输层（发送方的传输层和接收方的传输层）。

**差错控制**
IP层不可靠，如果应用层需要可靠性，需要由传输层来变得可靠。这是通过在传输层加入差错控制服务来实现。
差错控制主要负责以下几个方面：
  1. 发现并丢弃被破坏的分组
  2. 记录丢失和丢弃的分组并重传
  3. 识别重复分组并丢弃
  4. 缓冲时序分组知道丢失的分组到达

差错控制仅存在于发送方和接收方的传输层之间。
在传输层分组（packet）中加入一个字段来保存<span style="color:#f00">序号</span>。接收方传输层可以通知发送方传输层利用序号重传分组或者实现去重、重排失序。
接收方在收到正确的分组之后发送一个<span style="color:#f00">确认信号</span>。发送方在发送一个分组后就开启一个计时器，如果超时没有收到确认信号，就重发。

**流量控制和差错控制的组合**
发送端： 分组准备发送，采用下一个缓冲区空闲位置号码x作为分组的序号。当分组发送时，一个分组的备份存储在内存位置x，等待来自另一端的确认。当确认到达，分组被清除，内存位置空闲出来。
接收端：当带有序号y的分组到达时，被存储在内存位置y上，直到应用层准备好接受它。这是发送一个确认表明分组y已经到达。

**无连接服务**。传输层将数据块看做彼此没有关系的单元。流量控制、差错控制和拥塞控制都不能在无连接服务中有效实现。
**面向连接服务**。传输层的面向连接服务仅涉及两个主机，与网络层的面向连接服务（两个主机及中间的所有路由器都需要协调）不同。

### 3.2 传输层协议
<strong style="color:#f00">简单协议</strong>。简单的无连接协议，不使用任何控制。（真的不能再简单了。。。。）

<strong style="color:#f00">停止-等待协议</strong>。使用流量和差错控制。发送方和接收方都是用大大小为1的滑动窗口（缓冲区）。发送方发送一个分组就开始等待确认，确认到达后再发送下一个分组。
带宽利用率非常低。
*带宽延迟乘积* = 带宽*信号往返时间。

<strong style="color:#f00">回退N帧协议</strong>。为了提高效率，等待确认时可以传输多个分组。发送多个分组，但接收方的缓冲区只能接受一个分组。任何失序的分组到达都会被丢弃。
![回退N帧协议的发送窗口滑动过程](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3-4.png)

<strong style="color:#f00">选择性重复协议</strong>。发送窗口更小（大小为2^(m-1)，即如果序号是0-15，那么发送滑动窗口的大小为8），但是接受窗口和发送窗口大小一致。因此失序分组不需要被丢弃，只需要重新发送丢失分组即可（选择性重复）。
![选择性重复协议的发送窗口滑动过程](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3-5.png)

<strong style="color:#f00">双向协议：捎带</strong>。之前的协议都是单向的，数据分组只沿这一个方向流动，确认也是按一个方向传递。而现实中数据分组通常是双向流动的。当一个分组携带数据从A到B，也携带了确认反馈，确认了来自B的分组已经到达。

![TCP/IP协议簇中传输层协议的位置](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3-6.png)

### 3.3 用户数据报协议（UDP）
无连接不可靠传输层协议。
优点：非常简单，开销小。
缺点：只能提供非常有限的差错检验。

<strong style="color:#f00">用户数据报（user datagram）</strong>
![用户数据报格式](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3-7.png)
注意UDP只记录端口号。主机定位是由网络层完成。

无连接的结果就是，使用UDP的进程不能向UDP发送数据流，同时，每个请求必须足够小使能够装入用户数据报中（小于65507字节）。

UDP不提供流量控制、差错控制、拥塞控制，如果需要，使用UDP的进程应该自己提供这个服务。

<span style="color: #00f">校验和</span>:请见第五章。。。。

### 3.4 传输控制协议（TCP）
TCP是一个面向流的协议。

TCP使用<span style="color: #00f">字节流</span>传送数据，但是IP使用<span style="color: #00f">分组</span>方式而非字节流。因此在传输层，TCP将多个字节组合在一起成为一个分组，称为段（segment），给每个段添加头部，并将该段传递给IP层。

TCP是全双工通信，数据可以在同一时间双向流动。每个方向都有TCP的发送和接受缓冲区。

<span style="color:#f00">字节序号</span>。TCP为所有传输<span style="color: #00f">字节</span>编号，第一个字节的序号是一个随机值。
字节被编号后，TCP对发送的每一个<span style="color: #00f">段</span>分配一个序号，这个序号对应段中的第一个字节的序号。

<span style="color: #f00">确认号</span>。确认号定义了通信一方预期接受的下一个字节（例如现在已经接受了5362，那么确认号应该是5363）

<br>
![TCP段格式](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3-8.png)
注意头部规定了确认号

![TCP段中的控制字段](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3-9.png)

**<span style="color:#f00">TCP连接</span>**
TCP在较高层次上操作，使用IP服务向接收方传递独立的段，但他控制链接本身。如果段丢失或者损坏，就重新发送它。IP并不知道这个过程。
接下来介绍：连接建立、数据传输和连接终止三个过程
1. <span style="color: #00f">连接建立</span>
  <article>**三次握手**
  ![三次握手过程](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3-10.png)
    1. 客户发送第一个段<span style="color:#00f">SYN</span>。SYN段是一个控制端并且不懈怠数据，然后它消耗一个序号，因为需要被确认。
    2. 服务器发送第二个段，<span style="color:#00f">SYN + ACK段</span>。SYN段用于给从服务器发送的字节编号，ACK用于告诉客户服务器端的确认号。（是否可以这样理解，SYN是客户端定义的确认号，ACK是服务器定义的确认号）
    3. 客户发送第三个段，仅含<span style="color:#00f">ACK段</span>，用于向服务器确认收到第二个段。

  SYN泛洪攻击。伪造大量源IP地址发送SYN段，服务器消耗大量资源等待第三步ACK段确认，最终耗尽资源而崩溃。SYN泛洪攻击数据DOS攻击的一种。
  对于这种攻击，可以在特定的时间周期对连接请求进行限制，也可以过滤掉来自不需要的原地址的数据报。SCTP则采用cookie推迟资源分配知道一个完整的连接建立。
</article>

2. <span style="color: #00f">数据传输</span>
  ![数据传输过程](https://raw.githubusercontent.com/liujiajun1993/notes/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3-11.png)
  注意ack号用于确认。
  **PSH标志**用于告诉接收端的TCP，该段数据必须尽快传递给接受进程，而不需要等待缓冲器填满。一般情况下，接收端TCP都会等待缓冲区填满之后再传递数据给接收进程。
  **URG标志**告知接收端这是紧急数据，但并不享受优先服务，如何处理紧急数据由应用程序决定。

3. <span style="color: #00f">连接终止</span>
  方法一： 三次握手
  1. 客户TCP发送FIN段
  2. 服务器发送FIN + ACK
  3. 客户发送ACK段（接收到的服务器FIN段序号 + 1）
  
  方法二：半关闭四次握手
  一端停止发送数据之后，还可以持续接收数据。即半关闭。
  1. 客户端发送FIN实现半关闭
  2. 服务器发送ACK段确认半关闭
  3. 服务器继续发送数据，直到完毕。然后发送FIN段
  4. 客户端发送ACK段，连接关闭。

**RST标志**表示连接重置


P141